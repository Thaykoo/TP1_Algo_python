# Mini-Projet : Gestion de Biblioth√®que Num√©rique - Partie 2 : Organisation et Optimisation

## Objectif de la Partie 2

Remplacer la structure de donn√©es de base (liste Python) par un **Arbre Binaire de Recherche (BST)** pour am√©liorer l'efficacit√© de la recherche et maintenir l'ordre des documents de mani√®re dynamique.

## ‚öôÔ∏è Impl√©mentation du BST

Le BST est impl√©ment√© dans le fichier `bst.py` via deux classes :
* **`Node`** : Repr√©sente un n≈ìud dans l'arbre, stockant l'objet `Document` et les r√©f√©rences vers les fils gauche (`left`) et droit (`right`).
* **`BinarySearchTree`** : G√®re la racine de l'arbre et impl√©mente les m√©thodes de manipulation.

### 1. Insertion de Documents

* **M√©thode :** `BST.insert(document)`
* **Principe :** L'insertion est effectu√©e de mani√®re r√©cursive en comparant le titre du nouveau document avec celui des n≈ìuds existants. Si le nouveau titre est **inf√©rieur** au n≈ìud courant, il est ins√©r√© dans le sous-arbre **gauche** ; sinon, il est ins√©r√© dans le sous-arbre **droit**.
* **Complexit√© :** $O(\log n)$ en moyenne (pour un arbre √©quilibr√©). $O(n)$ dans le pire cas (arbre d√©g√©n√©r√© en liste).

### 2. Recherche de Documents

* **M√©thode :** `BST.search(titre)`
* **Principe :** La recherche est √©galement r√©cursive et suit la m√™me logique de comparaison que l'insertion.
* **Complexit√© :** $O(\log n)$ en moyenne. **C'est le gain majeur par rapport √† la Recherche S√©quentielle ($O(n)$) de la Partie 1.**

### 3. Parcours In-order

* **M√©thode :** `BST.in_order_traversal()`
* **Principe :** Le parcours suit l'ordre : **Gauche** $\rightarrow$ **Racine** $\rightarrow$ **Droite**.
* **R√©sultat :** Le parcours in-order garantit que les documents sont affich√©s dans l'ordre alphab√©tique de leurs titres, exploitant ainsi la propri√©t√© intrins√®que du BST.

## üìä Comparaison des Performances de Recherche

La fonction `comparer_recherche_performance()` est impl√©ment√©e pour valider le gain th√©orique apport√© par le BST.

* **Recherche S√©quentielle (Partie 1) :** $O(n)$
    * Dans une liste de taille $N$, il faut en moyenne $N/2$ comparaisons pour trouver un √©l√©ment. Le temps d'ex√©cution augmente **lin√©airement** avec $N$.
* **Recherche BST (Partie 2) :** $O(\log n)$
    * Dans un BST de taille $N$, le nombre de comparaisons est proportionnel √† la hauteur de l'arbre. Le temps d'ex√©cution augmente **logarithmiquement**, ce qui est beaucoup plus rapide pour de tr√®s grands $N$.

**R√©sultat Attendu :** La comparaison d√©montrera que la recherche sur le BST est **plusieurs centaines de fois plus rapide** que la recherche s√©quentielle pour un grand volume de documents, confirmant que le choix du BST est adapt√© pour l'optimisation des requ√™tes de recherche.