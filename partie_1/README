# Mini-Projet : Gestion de Biblioth√®que Num√©rique - Partie 1 : Fondations

## Objectif de la Partie 1

Cette partie √©tablit les fondations du syst√®me en utilisant les structures de donn√©es de base de Python (classe `Document`, liste `list`) et en impl√©mentant des algorithmes fondamentaux de tri et de recherche.

## üèóÔ∏è Architecture du Code

Le code est structur√© de mani√®re modulaire :
* `main.py` (√† la racine) : Le point d'entr√©e et le menu principal.
* **partie_1/** : Le paquetage contenant la logique.
    * `__init__.py` : Expose les classes et fonctions pour un import propre.
    * `document.py` : D√©finit la classe `Document` (Titre, Auteur, Mots-cl√©s).
    * `gestionnaire.py` : Contient les fonctions de gestion et les algorithmes de base.
    * `supplement_algo.py` : Contient l'algorithme de tri optimis√© et la fonction de comparaison des performances.

## üíæ Structure des Donn√©es

La collection de documents est g√©r√©e par une **liste Python standard (`list`)**. Chaque √©l√©ment est un objet de la classe `Document`.

## ‚öôÔ∏è Choix des Algorithmes de Base

### 1. Algorithme de Tri : Tri par Insertion (Insertion Sort)

| Fonction | `gestionnaire.trier_par_titre()` |
| :--- | :--- |
| **Complexit√©** | $O(n^2)$ |
| **Cl√© de Tri** | Titre du document (non sensible √† la casse). |

**Justification du choix :** C'est un algorithme facile √† comprendre et simple √† impl√©menter, id√©al pour illustrer les bases du tri par comparaison lors de la phase de fondation.

### 2. Algorithme de Recherche : Recherche S√©quentielle (Linear Search)

| Fonction | `gestionnaire.rechercher_par_titre()` |
| :--- | :--- |
| **Complexit√©** | $O(n)$ |
| **Crit√®re de Recherche** | Titre du document (recherche exacte, non sensible √† la casse). |

**Justification du choix :** Il s'agit de l'approche la plus √©l√©mentaire. Il fonctionne sur n'importe quelle collection, qu'elle soit tri√©e ou non, r√©pondant ainsi √† l'exigence du projet.

---

## ‚≠êÔ∏è SUPPL√âMENT BIN√îME : Optimisation et Comparaison

### 3. Algorithme de Tri Am√©lior√© : Tri Fusion (Merge Sort)

| Fichier | `supplement_algo.py` |
| :--- | :--- |
| **Complexit√©** | $O(n \log n)$ |
| **Justification** | Le Tri Fusion utilise la strat√©gie ¬´ Diviser pour r√©gner ¬ª. Sa complexit√© en $O(n \log n)$ garantit une **performance bien sup√©rieure** √† celle du Tri par Insertion, particuli√®rement lorsque la biblioth√®que contient un grand nombre de documents. |

### 4. Comparaison des Performances

La fonction `comparer_temps_execution` (dans `supplement_algo.py`) permet de chronom√©trer l'ex√©cution du Tri par Insertion ($O(n^2)$) et du Tri Fusion ($O(n \log n)$) sur des jeux de donn√©es de tailles croissantes.

**Observation Attendue :** Les r√©sultats d√©montrent clairement que le Tri Fusion est plus efficace pour la gestion de grandes collections, confirmant l'importance d'utiliser des algorithmes $O(n \log n)$ pour l'√©volutivit√©.

---
## üöÄ Ex√©cution

Pour lancer le programme, assurez-vous d'√™tre dans le dossier racine (`/MiniProjet_Bibliotheque`) et utilisez la commande : `python3 -m main`.